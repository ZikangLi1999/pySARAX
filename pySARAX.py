"""
Toolbox for LoongSARAX Verification on BER-II Benchmark

Author: LZK

Note:
- The default unit of quantities is
    Length:           cm
    Temperature:      K
    Atom Density:     atom / (cm * barn) = 1e24 * atom / cm^3

- Notification for deepcopy
    Be careful to use deepcopy. It is flexible but fallible and memory-costly.

- TODO List
    - (DONE) Core.check(): the possible conflict between structure parameters will NOT be checked now
    - Core.plotRadial(): unpretty proportion under some ring conditions, due to the mysterious parameter "gridsize" of matplotlib.hexbin()
    - De-couple the axial information "bounds" and class Section
    - Section.check() to do

File Log:
2022-12-8   File created
2022-12-9   Concept design
2022-12-12  Material, Section, Assembly completed
2022-12-13  Core.check(), Core.toLAVENDER(), Core.plotRadial(), Core.specifyID() completed;
            Assembly reconstructed (dict-based -> list-based)
2022-12-14  Core.plotAxiel(), Core.complete() completed;
            Add parameter "deepcopy" in every class with method "copy()"
2022-12-15  Core.meshing() completed;
            Section.toTULIP() and Core.toTULIP() is modified with consideration of "supercell";
            The first TULIP card generated by this script
2022-12-16  Core.toLAVENDER() completed;
            Extra parameter "coolant" is introduced into Core, to fill the blank under/above Assembly in Core
2022-12-18  All basically completed;
            Test case-0 & case-1 conducted
2023-1-22   Conceptual design of Material.addElement()
2023-1-23   Update Material.parseZAIDS() due to the rewriting of dataBox._PERIODIC_TABLE;
            Section.append(), appendRod(), appendRegion() modified, new parameter "bounds" added (ill-advised);
            Assembly.copy() modified, the type name & location are added as parameters;
            Test case-2 conducted
2023-1-25   Section.append(), appendRod(), appendRegion() modified, parameter "bounds" removed;
            Assembly.setRefPlane() completed, to infer the bounds coordinates from section height and reference plane
2023-1-30   Material.__add__(), __rmul__() completed
2023-2-1    Fix: scSection of supercell is added into section list in Core.specifyID()
2023-2-2    Replace all warnings.warn() with print() to make terminal infromation more concise
2023-3-20   Remove nucldies with too low density from the materials
"""
import os
import copy
import datetime
# import warnings
import numpy as np
import pandas as pd

from config import _PERIODIC_TABLE, _INDENT, _BULK_TEMP, _GROUP_STRUCTURE

# Basic information
__PROGRAM__ = "pySARAX"
__AUTHOR__ = "Zikang LI"
__VERSION__ = 1.0


class Material:

    def __init__(self, name) -> None:
        """
        Create a Material object with name and composition
        
        Input
        -----
        name: str, the identical name of this Material
        """
        self.name = name
        self.id = -1
        self.composition = pd.DataFrame(columns=("Nuclide", "Density", "Temperature"))
        self.removeLowDensity = True
    
    def addNuclide(self, nuclide, density, temperature) -> None:
        """
        Add a nuclide into this Material
        nuclide: str, the nuclide symbol, like "Pu239"
        density: float, the atom density of nuclide in UNIT "atom/(cm*barn)"
        temperature: float, the temperature of material in UNIT "K" 
        """
        # Check input
        if type(nuclide) is not str:
            raise TypeError("Input nuclide is not type str. nuclide={}".format(nuclide))
        try:
            density = float(density)
        except ValueError:
            raise TypeError("Cannot convert density to float type. density={}".format(density))
        try:
            temperature = float(temperature)
        except ValueError:
            raise TypeError("Cannot convert temperature to float type. temperature={}".format(temperature))
        
        self.composition = self.composition.append(\
            {"Nuclide": nuclide, "Density": density, "Temperature": temperature}, ignore_index=True)

    def addElement(self, element, density, temperature) -> None:
        """
        Add an element into this Material
        element: str, the element symbol, like "Fe"
        density: float, the atom density of nuclide in UNIT "atom/(cm*barn)"
        temperature: float, the temperature of material in UNIT "K" 
        """
        # Check input
        if type(element) is not str:
            raise TypeError("Input element is not type str. element={}".format(element))
        try:
            density = float(density)
        except ValueError:
            raise TypeError("Cannot convert density to float type. density={}".format(density))
        try:
            temperature = float(temperature)
        except ValueError:
            raise TypeError("Cannot convert temperature to float type. temperature={}".format(temperature))
        
        # Convert element to nuclide based on natural enrichment
        nuclides = _PERIODIC_TABLE.elem2nuc(element=element, density=density)
        for nuc, den in nuclides:
            self.composition = self.composition.append(\
                {"Nuclide": nuc, "Density": den, "Temperature": temperature}, ignore_index=True)

    def fromCSV(self, csvPath, defaultTemp=_BULK_TEMP) -> None:
        """
        Read material composition from a CSV file
        csvPath: pathLike
        defaultTemp: float, the default temperature of material, only used when "Temperature" is missing in CSV
        """
        self.composition = pd.read_csv(csvPath)

        # If the nuclide is given in ZAIDS format, 
        #     traverse every row of the raw data, then convert the ZAIDS to isotope symbol
        if "ZAIDS" in self.composition:
            self.composition["ZAIDS"] = self.composition["ZAIDS"].apply(lambda row: self.parseZAIDS(int(row)))
            self.composition.columns = ("Nuclide", "Density")
        
        # If temperature not given, set it to defaultTemp
        if "Temperature" not in self.composition:
            self.composition["Temperature"] = \
                defaultTemp * np.ones(shape=len(self.composition), dtype=float)

    def fromDataFrame(self, df, defaultTemp=_BULK_TEMP) -> None:
        """
        Read material composition from a pandas.DataFrame
        df: pandas.DataFrame
        defaultTemp: float, the default temperature of material, only used when "Temperature" is missing in DataFrame
        """
        # Check df type
        if type(df) is not pd.DataFrame:
            raise TypeError("Input df is not type pandas.DataFrame. df={}".format(df))
        
        self.composition = df.copy()

        # Convert ZAIDS to nuclide if necessary
        if "ZAIDS" in self.composition:
            self.composition["ZAIDS"] = self.composition["ZAIDS"].apply(lambda row: self.parseZAIDS(int(row)))
        
        # If temperature not given, set it to defaultTemp
        if "Temperature" not in self.composition:
            self.composition["Temperature"] = \
                defaultTemp * np.ones(shape=len(self.composition), dtype=float)

        # Change the column title
        self.composition.columns = ("Nuclide", "Density", "Temperature")

    def check(self) -> bool:
        """
        Check the data of material composition before converting to TULIP

        Checking Items
        --------------
        - Remove the nuclides with density lower than 1E-15, which may lead to NaN when calculating the backgroud cross-section
        """
        if self.removeLowDensity:
            self.composition = self.composition[self.composition['Density'] >= 1E-15]
        
        return True

    def toTULIP(self) -> str:
        """
        Convert the material composition to TULIP format
        """
        # Check Material ID
        if self.id == -1:
            raise RuntimeError("Material ID not specified.")
        
        # Check Material Composition
        if not self.check():
            raise RuntimeError("Material check NOT passed in m{}".format(self.id))
        
        slist = ["! material: {}".format(self.name), "m{}".format(self.id)]
        # Traverse every row(nuclide), convert the data to TULIP format:
        # m(id)
        #     (nuclide)  (Density)  (Temperature)
        for idx, row in self.composition.iterrows():
            slist.append("{}{:<9}{:>12.3E}{:>10.2f}".format(\
                _INDENT, row["Nuclide"], row["Density"], row["Temperature"]))
        
        slist.append('\n')
        return '\n'.join(slist)

    def parseZAIDS(self, zaids):
        """
        Convert the ZAIDS to isotope symbol
        zaids: str or int, like "96242"

        Remark: This method is weak-coupled, which can be moved out of this class
        Update: Use PeriodicTable.zaids2nuc() instead. This method will be kept for compatibility
        """
        if type(zaids) == str:
            protonNumber = int(zaids[:-3])
            massNumber = int(zaids[-3:])
        if type(zaids) == float:
            zaids = int(zaids)
            protonNumber = zaids // 1000
            massNumber = zaids % 1000
        if type(zaids) == int:
            protonNumber = zaids // 1000
            massNumber = zaids % 1000
        # elementName = _PERIODIC_TABLE[_PERIODIC_TABLE['Nr'] == protonNumber]['Symbol'].item()
        elementName = _PERIODIC_TABLE.proton2elem(proton=protonNumber)
        return ''.join((elementName, str(massNumber)))

    def __str__(self) -> str:
        slist = ["Material"]
        slist.append("{:<15}{}".format("name:", self.name))
        slist.append("{:<15}{:d}".format("ID:", self.id))
        slist.append("{:<15}{:d} nuclides".format("composition:", len(self.composition)))
        return '\n'.join(slist)
    
    def __add__(self, other):
        # Find out all of the nuclides in this & other
        allNuclides = np.unique(np.append(self.composition['Nuclide'].values, other.composition['Nuclide'].values))
        # print(self.composition)
        # print(other.composition)

        result = Material(name='{}+{}'.format(self.name, other.name))
        getItem = lambda df: df.item() if not df.empty else 0.0
        for nuc in allNuclides:
            thisNuc = self.composition[self.composition['Nuclide'] == nuc]
            otherNuc = other.composition[other.composition['Nuclide'] == nuc]
            # print(nuc, thisNuc['Density'], otherNuc['Density'])
            result.addNuclide(
                nuc,
                getItem(thisNuc['Density']) + getItem(otherNuc['Density']),
                (getItem(thisNuc['Temperature']) + getItem(otherNuc['Temperature'])) / sum([1 - df.empty for df in (thisNuc['Temperature'], otherNuc['Temperature'])])
            )
        
        return result
    
    def __rmul__(self, other):
        result = Material(name='{:.4E}*({})'.format(other, self.name))
        result.composition = self.composition.copy()
        result.composition['Density'] = other * result.composition['Density']
        return result


class Section:

    def __init__(self, name, ring=0, pitch=0., height=None, eqMethod="homo") -> None:
        """
        A Section of a segement in assembly

        Input
        -----
        name: str, the name of Section
        ring: int, the ring number of rod
        pitch: float, the pitch of rod
        bounds: (float, float), the coordinate height of the lower and higher bound
        height: float, the height of this Section (which should have been de-coupled with Section)
        eqMethod: str, the equivalence method in cross-section calculation: ["homo", "1D", "supercell"]
        scSection: Section, the adjacent section (ONLY ONE) of surrounding assembly in supercell
        """
        self.name = name
        self.id = -1
        self.ring = ring
        self.pitch = pitch
        self.height = height
        self.bounds = (0., 0.)
        self.rod = []
        self.region = []
        self.eqMethod = eqMethod
        self.scSection = None

        # Auxiliary variables
        self.r = -1
        self.k = -1

    def append(self, shape, size, material) -> None:
        """
        Append a geometry into this Section

        Input
        -----
        shape: str, "rod"/"circ"/"c" or "region"/"hex"/"h"
        size: float, the characteristic size
        material: class Material
        """
        # Convert the type of size into float
        if type(size) is not float:
            size = float(size)
        
        # Check material
        if type(material) is not Material:
            raise TypeError("Input material is not type Material. material={}".format(material))
        
        # Modify bounds if given
        # if type(bounds) is tuple or type(bounds) is list:
        #     bounds = tuple(bounds)
        #     if len(bounds) != 2:
        #         raise ValueError("Input bounds has NOT 2 elements.")
        #     if type(bounds[0]) is not float or type(bounds[1]) is not float:
        #         raise TypeError("Input bounds are type {} & {}, which should be float.".format(type(bounds[0], type(bounds[1]))))
        #     self.bounds = bounds

        # Check shape & append data
        if type(shape) is not str:
            raise TypeError("Input shape is not type str. shape={}".format(shape))
        shape = shape.lower()
        if shape == "rod" or shape == "circ" or shape == "c":
            shape = "rod"
            self.rod.append((size, material))
        elif shape == "region" or shape == "hex" or shape == "h":
            shape = "region"
            self.region.append((size, material))
        else:
            raise ValueError("Invalid shape: {}".format(shape))
    
    def appendRod(self, size, material) -> None:
        """
        Append a rod geometry into this Section
        size: float, the characteristic size
        material: class Material
        """
        self.append(shape="rod", size=size, material=material)

    def appendRegion(self, size, material) -> None:
        """
        Append a region geometry into this Section
        size: float, the characteristic size
        material: class Material
        """
        self.append(shape="region", size=size, material=material)
    
    def check(self) -> bool:
        """
        Check this Section model
        """
        isPass = True

        if self.ring != len(self.rod):
            isPass = False
            print("Warning: dismatch of ring_num and rod_num in Section [{}]".format(self.name))

        return isPass

    def toTULIP(self, sc=False) -> str:
        """
        Convert the Section data to TULIP format

        Input
        -----
        sc: bool, add "sc_" to the head of every keyword of marginal assembly in supercell
        """
        # Check Section ID & ring
        if self.id == -1:
            raise RuntimeError("Section {} ID not specified.".format(self.name))
        if self.ring == -1 and len(self.rod) > 0:
            raise RuntimeError("Ring number not specified in Section {}.".format(self.name))
        
        # Add "sc_" to supercell keyword
        keywordHeader = "sc_" if sc else ""

        if not sc:
            slist = ["! Section: {}".format(self.name), "mat{:d}".format(self.id)]
        else:
            slist = []
        
        # Rod
        if len(self.rod) > 0:
            slist.append("{}rod".format(keywordHeader))
            slist.append("{}{:<14}{:d}".format(_INDENT, "{}rod_num".format(keywordHeader), self.ring))
            rod_geo = "{}{:<14}".format(_INDENT, "{}rod_geo".format(keywordHeader))
            rod_mat = "{}{:<14}".format(_INDENT, "{}rod_mat".format(keywordHeader))
            for size, material in self.rod:
                rod_geo += "{:<8.4f}".format(size)
                rod_mat += "{:<8d}".format(material.id)
            slist.append(rod_geo)
            slist.append(rod_mat)
            # Keyword "rod_dis" is not needed in supercell
            if not sc:
                slist.append("{}{:<14}{:<8.4f}".format(_INDENT, "rod_dis", self.pitch))
            if not sc and self.eqMethod != "supercell":
                slist.append("{}{:<14}{}".format(_INDENT, "ring_num", \
                    " ".join(list([str(i) for i in range(1, self.ring+1)]))))
        
        # Region
        if len(self.region) > 0:
            slist.append("{}region   hex".format(keywordHeader))
            region_geo = "{}{:<14}".format(_INDENT, "{}region_geo".format(keywordHeader))
            region_mat = "{}{:<14}".format(_INDENT, "{}region_mat".format(keywordHeader))
            for size, material in self.region:
                region_geo += "{:<8.4f}".format(size)
                region_mat += "{:<8d}".format(material.id)
            slist.append(region_geo)
            slist.append(region_mat)
        
        # Remove the keyword "end" in central section, folloed by "sc_rod"
        if self.eqMethod != "supercell":
            slist.append("end")
            slist.append('\n')
        
        return '\n'.join(slist)

    def copy(self, name, deepcopy=False):
        """
        Create a copy of this Section

        Input
        -----
        name: str, a new name for this copy, use "@ORIGIN" to represent the original name
        deepcopy: bool, whether replace copy.copy() with copy.deepcopy()

        Example
        -------
        ```python
        >>> origin = Section(name="fuel")
        >>> copy1 = origin.copy(name="copy")
        >>> copy1.name
        "copy"
        >>> copy2 = origin.copy(name="@ORIGIN_copy")
        >>> copy2.name
        "fuel_copy"
        ```
        """
        # Check input
        try:
            name = str(name)
        except ValueError:
            raise TypeError("Input name could not be converted to string")
        
        newName = name.replace("@ORIGIN", self.name)
        if newName == self.name:
            raise ValueError("Names conflict between Section and its copy.")

        # Create copy
        # Maybe the copy could be simplified
        sectionCopy = Section(name=newName, ring=self.ring, pitch=self.pitch)
        sectionCopy.id = -1
        sectionCopy.bounds = self.bounds
        sectionCopy.height = self.height
        if deepcopy:
            sectionCopy.rod = copy.deepcopy(self.rod)
            sectionCopy.region = copy.deepcopy(self.region)
        else:
            sectionCopy.rod = copy.copy(self.rod)
            sectionCopy.region = copy.copy(self.region)
        return sectionCopy

    def __str__(self) -> str:
        slist = ["Section"]
        slist.append("{:<15}{}".format("name:", self.name))
        slist.append("{:<15}{:d}".format("ID:", self.id))
        slist.append("{:<15}{:d}".format("ring:", self.ring))
        slist.append("{:<15}{:.4f}".format("pitch: ", self.pitch))
        slist.append("{:<15}{:<10.4f}{:<10.4f}".format("bounds:", *self.bounds))
        slist.append("{:<15}{:d}".format("rod:", len(self.rod)))
        slist.append("{:<15}{:d}".format("region:", len(self.region)))

        return '\n'.join(slist)


class Assembly:

    def __init__(self, typeName, location) -> None:
        """
        An single assembly

        Input
        -----
        typeName: str, could be ["driver", "control", ...]
        location: str, like "02C08"

        Usage
        -----
        ```python
        pass
        ```
        """
        self.id = -1
        self.type = typeName
        self.location = location
        self.sections = []

        # Auxiliary variables
        self.r = -1
        self.k = -1

    def addSection(self, section, bounds=None) -> None:
        """
        Add a Section into this Assembly

        Input
        -----
        section: class Secion
        bounds: tuple, the upper & lower bound of section

        Caution
        -------
        If the bounds of section are not set, sections must be added strictly by order from bottom to top.
        """
        # Check input
        if type(section) is not Section:
            raise TypeError("Input section is not Section type. section={}".format(section))

        # Modify bounds if given
        if bounds is None:
            pass
        elif type(bounds) is tuple:
            section.bounds = bounds
        else:
            raise TypeError("Input bounds is type {}, which should be tuple".format(type(bounds)))
        
        self.sections.append(section)
    
    def setRefPlane(self, refSec, bias=0.0):
        """
        Set the reference plane of this Assembly

        Input
        -----
        refSec: Section or int, the object or order of the Section locating at reference plane
        bias: float, the distance from the lower bound to the reference plane

        Caution
        -------
        Please call this method after all sections added.
        """
        # Check input
        if type(refSec) is int:
            refSecId = refSec
            refSec = self.sections[refSecId]
        elif type(refSec) is Section:
            # Find the ID of reference Section
            for secId, sec in enumerate(self.sections):
                if sec == refSec:
                    refSecId = secId
        
        # Check heights
        errSecs = []
        for sec in self.sections:
            if sec.height is None:
                errSecs.append(sec.name)
        if len(errSecs) > 0:
            raise RuntimeError("The height of Sections: {} have NOT been set.".format(str(errSecs)))
        
        # Auxiliary function
        sumHeight = lambda secs: sum([sec.height for sec in secs])

        # Determine the coordinates of Section bounds
        for secId, sec in enumerate(self.sections):
            if secId < refSecId:
                lowerBound = - sumHeight(self.sections[secId:refSecId]) - bias
                higherBound = - sumHeight(self.sections[secId+1:refSecId]) - bias
            else:
                lowerBound = sumHeight(self.sections[refSecId:secId]) - bias
                higherBound = sumHeight(self.sections[refSecId:secId+1]) - bias
            sec.bounds = (lowerBound, higherBound)

    def copy(self, typeName, location, deepcopy=False):
        """
        Create a copy of this Assembly

        Input
        -----
        typeName: str, the type name of this copy. Use '@ORIGEN' to represent the original type name
        location: str, the location identifier of this copy
        deepcopy: bool, whether replace copy.copy() with copy.deepcopy()
        """
        # Check input
        if type(typeName) is not str:
            raise TypeError("Input typeName is type {}, which should be str.".format(type(typeName)))
        if type(location) is not str:
            raise TypeError("Input location is type {}, which should be str.".format(type(location)))

        typeName = typeName.replace('@ORIGEN', self.type)

        assemblyCopy = Assembly(typeName=typeName, location=location)
        assemblyCopy.id = -1
        if deepcopy:
            assemblyCopy.sections = copy.deepcopy(self.sections)
        else:
            assemblyCopy.sections = copy.copy(self.sections)

        return assemblyCopy

    def toLAVENDER(self, meshgrid, coolant) -> str:
        """
        Convert the data of Assembly to LAVENDER format (keyword FA_type)

        Input
        -----
        meshgrid: arrayLike, the mesh grid of the Core
        coolant: Section, use to fill the blank under/above the assembly
        """
        slist = ["{:<16}".format("FA_type")]
        slist.append("{:<16d}".format(self.id))

        idlist = []
        # Traverse every mesh grid, and determine which section does it locate in
        for idx in range(len(meshgrid) - 1):
            isUnderAssembly = True
            isAboveAssembly = True
            for sec in self.sections:
                # Determine whether the grid is under/above the current assembly
                if isUnderAssembly and meshgrid[idx] >= sec.bounds[0]:
                    isUnderAssembly = False
                if isAboveAssembly and meshgrid[idx+1] <= sec.bounds[1]:
                    isAboveAssembly = False
                
                # Mesh grid is included in Section
                if sec.bounds[0] <= meshgrid[idx] and sec.bounds[1] >= meshgrid[idx+1]:
                    if len(idlist) == 0:
                        idlist.append("{:d}".format(sec.id))
                        break
                    # The current grid is in the same section as the previous several ones
                    elif int(idlist[-1].split('*')[-1]) == sec.id:
                        if '*' in idlist[-1]:
                            idlist[-1] = "{:d}*{:d}".format(1+int(idlist[-1].split('*')[0]), sec.id)
                            break
                        else:
                            idlist[-1] = "{:d}*{:d}".format(2, sec.id)
                            break
                    else:
                        idlist.append("{:d}".format(sec.id))
                        break
            
            # Mesh grid is under/above the current assembly, fill it with the coolant
            if isUnderAssembly:
                idlist.append("{:d}".format(coolant.id))
            elif isAboveAssembly:
                idlist.append("{:d}".format(coolant.id))
            # If the previous section is also coolant, merge them
            if (isUnderAssembly or isAboveAssembly) and len(idlist) > 1:
                if int(idlist[-2].split('*')[-1]) == coolant.id:
                    if '*' in idlist[-2]:
                        idlist[-2] = "{:d}*{:d}".format(1+int(idlist[-2].split('*')[0]), coolant.id)
                    else:
                        idlist[-2] = "{:d}*{:d}".format(2, coolant.id)
                    idlist.pop()
        
        slist.append(" ".join(idlist))
        return ''.join(slist)

    def check(self) -> bool:
        """
        Check the axial structure of Assembly
        """
        self.sections = sorted(self.sections, key=lambda x: x.bounds[0])
        ifpass = True
        prev = None
        for sec in self.sections:
            if prev is None:
                prev = sec.bounds[1]
                continue
            if prev != sec.bounds[0]:
                # warnings.warn("Section {} in Assembly {} does not match its previous one.".format(sec.name, self.location))
                print("Warning: Section [{}] in Assembly [{}] does not match its previous one.".format(sec.name, self.location))
                ifpass = False
            prev = sec.bounds[1]
        
        return ifpass

    def __str__(self) -> str:
        slist = ["Assembly"]
        slist.append("{:<15}{:d}".format("ID:", self.id))
        slist.append("{:<15}{}".format("type:", self.type))
        slist.append("{:<15}{}".format("location:", self.location))
        slist.append("{:<15}{:d}".format("sections:", len(self.sections)))

        return '\n'.join(slist)


class Assemblies:

    def __init__(self, name) -> None:
        """
        A list of assemblies in the same type

        Input
        -----
        name: str, could be ["driver", "control", "safety", ...] or other identifier
        csvPath: pathLike, The path of "Benchmark Materials CSV Files" directory

        Usage
        -----
        1. List-like: 
        ```python
        for assembly in assemblies:
            assert type(assembly) == Assembly
        ```
        2. Dict-like:
        ```python
        >>> assemblies["02C08"]
        <Assembly object at location "02C08">
        ```
        """
        self.name = name
        self.assemblies = []

        # Auxilary variables for __iter__
        self.locations = None
        self.loc = None
        
    def addAssembly(self, assembly) -> None:
        """
        Add an Assembly into this Assemblies

        Input
        -----
        assembly: class Assembly
        """
        if type(assembly) is not Assembly:
            raise TypeError("Input assembly is not type Assembly. assembly={}".format(assembly))
        
        self.assemblies.append(assembly)

    def __len__(self) -> int:
        return len(self.assemblies)

    def __getitem__(self, key) -> Assembly:
        if type(key) is int:
            return self.assemblies[key]
        if type(key) is str:
            for assembly in self.assemblies:
                if key == assembly.name:
                    return assembly
            # If no assembly's name == key, raise a KeyError
            raise KeyError("No assembly found by key={}".format(key))
        else:
            raise KeyError("Invalid key type {}".format(type(key)))
    
    def __iter__(self):
        self.loc = -1
        # self.locations = tuple(self.assemblies.keys())
        return self

    def __next__(self) -> Assembly:
        self.loc += 1
        # if self.loc >= len(self.locations):
        #     raise StopIteration
        # return self.assemblies[self.locations[self.loc]]
        if self.loc >= len(self.assemblies):
            raise StopIteration
        return self.assemblies[self.loc]
    
    def __str__(self) -> str:
        slist = ["Assemlbies"]
        slist.append("{:<15}{}".format("name:", self.name))
        slist.append("{:<15}{}".format("number:", len(self.assemblies)))

        return '\n'.join(slist)


class Core:

    def __init__(self, name, ring, pitch, coolant) -> None:
        """
        A hexagonal core

        Input
        -----
        name: str, the name of this core
        ring: int, the ring number of this core
        pitch: float, the pitch of assembly lattice
        coolant: Section, used to fill the blank at the bottom/top of the Core
        """
        self.name = name
        self.ring = ring
        self.lattice = []
        self.coolant = coolant

        # CONTROL parameters
        self.power = -1.
        self.gammaHeat = False
        self.depletion = False
        self.rodSearch = False
        self.targetKeff = 0.
        self.worth = False
        self.reactivity = False
        self.neutronBalance = False
        self.outputPower = False
        self.outputVTK = True
        self.restart = False
        self.thermal = False
        self.reconstruct = False

        # METHOD parameters
        self.SNOrder = 4
        self.maxInnerIter = 16
        self.maxOuterIter = 500
        self.RMSInner = 5.0E-6
        self.RMSOuter = 1.0E-5
        self.RMSEigen = 1.0E-5
        self.openMPThread = 8
        self.cmacc = True
        self.spaceOrder = 2

        # MATERIAL parameters
        self.lowScatter = False

        # GEOMETRY parametera
        self.meshgrid = np.zeros(shape=0)
        self.boundaryConditions = (0, 0)
        self.pitch = pitch

        # Auxiliary variables
        self.completed = False
        self.assemblies = []
        self.sections = []
        self.materials = []

    def addRing(self, ring) -> None:
        """
        Add a ring of assemblies into this core

        Input
        -----
        ring: list (or Assemblies @TODO), the assemblies in clockwise order, starting at 60 degree (upper-right)
        """
        # Check input
        for assembly in ring:
            assert type(assembly) is Assembly
        
        self.lattice.append(ring)

    def complete(self) -> None:
        """
        Complete Mesh & ID Generation after basic modeling
        """
        if not self.check():
            raise ValueError("Core check not passed. Please check up model again.")
        
        self.specifyID()
        self.completed = True

    def check(self) -> bool:
        """
        Check the structure of this core
        """
        ifpass = True
        # Check whether self.lattice mathes self.ring
        if self.ring != len(self.lattice):
            ifpass = False
            # warnings.warn("Warning: lattice dismatch ring-number of core. Now: {:<6d} Ref: {:<6d}".format(len(self.lattice), self.ring))
            print("Warning: lattice dismatch ring-number of core. Now: {:<6d} Ref: {:<6d}".format(len(self.lattice), self.ring))
        
        # Check the number of assemblies in each ring
        for r, ring in enumerate(self.lattice):
            ref = 6*r if r>0 else 1
            if ref != len(ring):
                ifpass = False
                # warnings.warn("Warning: lattice dismatch hexagonal lattice in ring {:d}. Now {:<6d} Ref: {:<6d}".format(r+1, len(ring), ref))
                print("Warning: lattice dismatch hexagonal lattice in ring [{:d}]. Now {:<6d} Ref: {:<6d}".format(r+1, len(ring), ref))
            for k, assembly in enumerate(ring):
                if not assembly.check():
                    # warnings.warn("Warning: assembly check not passed in ({:d}, {:d})".format(r+1, k+1))
                    print("Warning: assembly check not passed in {}".format((r+1, k+1)))
                    ifpass = False

        return ifpass

    def meshing(self, tolerance=0.1) -> np.ndarray:
        """
        Generate the axial mesh of the whole core

        Input
        -----
        tolerance: float, the maximum height difference to neglect for approximation, ~0.1 cm for SARAX

        Caution
        -------
        The heights of Sections may be modified if there is any Section whose height is close enough to it. 
        The reason is that nodal method calculation may diverge or give wrong result with too-fine mesh grid.
        Therefore, it is suggensted to set the parameter tolerance higher than the minimum distinguishable distance.
        For LoongSARAX, the minimum distinguishable distance is about 0.1 cm, according to Aixin LI in XJTU.
        """
        # Prepare data: collect axial heights of all sections
        heights = set()
        for sec in self.sections:
            heights.add(sec.bounds[0])
            heights.add(sec.bounds[1])
        heights = sorted(list(heights))

        # Approximation: two heights whose distance <= tolerance will be regarded as the same one
        meshgrid = set()
        approxBuffer = set()
        for height in heights:
            # Initialize
            if len(approxBuffer) == 0:
                approxBuffer.add(height)
                continue
            else:
                lower, higher = min(approxBuffer), max(approxBuffer)
                # The current height is close to its adjacent ones, add it into approximation buffer
                if abs(height - lower) <= tolerance and abs(height - higher) <= tolerance:
                    approxBuffer.add(height)
                    continue
                # The current height is far away from its adjacent ones
                # Do approximation on buffer, pop them out to prepare for next approximation
                else:
                    averageHeight = sum(approxBuffer) / len(approxBuffer)
                    meshgrid.add(averageHeight)
                    approxBuffer.clear()
                    approxBuffer.add(height)
        # Do not forget the possible height left in buffer
        if len(approxBuffer) > 0:
            averageHeight = sum(approxBuffer) / len(approxBuffer)
            meshgrid.add(averageHeight)
            approxBuffer.clear()

        # Convert the meshgrid into numpy.ndarray, and sort it
        meshgrid = np.array(list(meshgrid), dtype=np.float)
        meshgrid = np.sort(meshgrid)

        # Approximate the too-close Sections
        for gridHeight in meshgrid:
            for sec in self.sections:
                for i in range(2):
                    if abs(gridHeight - sec.bounds[i]) > 0 and abs(gridHeight - sec.bounds[i]) <= tolerance:
                        bounds = list(sec.bounds)
                        originalBound = bounds[i]
                        bounds[i] = gridHeight
                        sec.bounds = tuple(bounds)
                        print("Warning: The No.{:d} bound {:.4f} of Section ({}) has been approximated to {:.4f}".format(
                            i, originalBound, sec.name, gridHeight))

        self.meshgrid = meshgrid
        self.coolant.bounds = (float(min(self.meshgrid)), float(max(self.meshgrid)))
        return meshgrid

    def specifyID(self) -> None:
        """
        Specify the ID of every Assembly, Section, and Material in this Core
        """
        assemblies = set()
        sections = set()
        materials = set()

        # Traverse the whole Core
        for r, ring in enumerate(self.lattice):
            for k, assembly in enumerate(ring):
                assembly.r = r
                assembly.k = k
                assemblies.add(assembly)

                for section in assembly.sections:
                    if section.eqMethod == 'supercell':
                        sections.add(section.scSection) # Specify ID for supercell section, or core check will NOT pass
                    section.r = r
                    section.k = k
                    sections.add(section)
                    for _, material in section.rod:
                        materials.add(material)
                    for _, material in section.region:
                        materials.add(material)

        sections.add(self.coolant)
        for _, material in self.coolant.region:
            materials.add(material)
        
        # Specify ID
        assemblies = sorted(list(assemblies), key=lambda x: x.location)
        sections = sorted(list(sections), key=lambda x: ' '.join((x.eqMethod, x.name)))
        materials = sorted(list(materials), key=lambda x: x.name)

        for i, assembly in enumerate(assemblies):
            assembly.id = i + 1
        for i, section in enumerate(sections):
            section.id = i + 1
        for i, material in enumerate(materials):
            material.id = i + 1
        
        # Prepare for plot
        self.assemblies = assemblies
        self.sections = sections
        self.materials = materials

    def toTULIP(self) -> str:
        """
        Convert the whole Core to TULIP format
        """
        # Check the integrety of Core
        if not self.completed:
            raise RuntimeError("Core has not completed yet. Please call Core.complete() first.")
        
        # Traverse every sections and materials, and call their methods toTULIP()
        tulipList = []

        # INFO
        tulipList.append("! This file is generated by {}.".format(__PROGRAM__))
        tulipList.append("! CASENAME: {}".format(self.name))
        tulipList.append("! DATE: {}".format(datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
        tulipList.append("\n")

        # CONTROL
        tulipList.append("! " + 16*"=" + " CONTROL " + 16*"=")
        tulipList.append("CONTROL:")
        tulipList.append("{:<22}{:d}".format("n_mat", len(self.sections)))
        tulipList.append("{:<22}{:d}".format("n_material", len(self.materials)))
        tulipList.append("{:<22}{}".format("leakage_correct", "none"))
        tulipList.append("{:<22}{:<8d}{:<8d}{:<8d}".format("group_info", *_GROUP_STRUCTURE))

        geom_kind = []
        for sec in self.sections:
            if sec.eqMethod == "homo":
                gk = "1"
            elif sec.eqMethod == "1-D":
                gk = "2"
            elif sec.eqMethod == "supercell":
                gk = "3"
            else:
                raise ValueError("Incorrect equivalence method {} in section {}".format(sec.eqMethod, sec.name))
            # Use "xx*yy" form if the last one is same as the current one
            if len(geom_kind) > 0 and geom_kind[-1][-1] == gk:
                if '*' not in geom_kind[-1]:
                    geom_kind[-1] = "2*{}".format(gk)
                else:
                    geom_kind[-1] = str(1 + int(geom_kind[-1][:-2])) + '*' + gk
            else:
                geom_kind.append(gk)
        geom_kind = ' '.join(geom_kind)
        tulipList.append("{:<22}{}".format("geom_kind", geom_kind))
        tulipList.append("\n")
        
        # GEOMETRY
        tulipList.append("! " + 16*"=" + " GEOMETRY " + 16*"=")
        tulipList.append("GEOMETRY:")
        for section in self.sections:
            tulipList.append(section.toTULIP())
            # Supercell Equivalence Method
            if section.eqMethod == "supercell":
                # Locate the adjacent assembly and append it as "sc_rod" and "sc_region"
                tulipList.append(section.scSection.toTULIP(sc=True))
        
        # MATERIAL
        tulipList.append("! " + 16*"=" + " MATERIAL " + 16*"=")
        tulipList.append("MATERIAL:")
        for material in self.materials:
            tulipList.append(material.toTULIP())
        
        return "\n".join(tulipList)

    def toLAVENDER(self) -> str:
        """
        Convert core data to LAVENDER format
        """
        # Check the integrety of Core
        if not self.completed:
            raise RuntimeError("Core has not completed yet. Please call Core.complete() first.")

        slist = []

        # INFO
        slist.append("! This file is generated by {}.".format(__PROGRAM__))
        slist.append("! CASENAME: {}".format(self.name))
        slist.append("! DATE: {}".format(datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
        slist.append("\n")

        # CASENAME
        slist.append("! " + 36*"=" + " CASENAME " + 36*"=")
        slist.append("CASENAME: {}".format(self.name))
        slist.append("\n")

        # CONTROL
        bool2tf = lambda x: "T" if x else "F"
        slist.append("! " + 36*"=" + " CONTROL " + 36*"=")
        slist.append("CONTROL:")
        slist.append("{:<16}{:<16}{:<16}".format("!", "power(Wth)", "(n,gamma)heating"))
        slist.append("{:<16}{:<16.4E}{:<16}".format("steady", self.power, bool2tf(self.gammaHeat)))
        slist.append("{:<16}{:<16}".format("!", "on-off"))
        slist.append("{:<16}{:<16}".format("depletion", bool2tf(self.depletion)))
        slist.append("{:<16}{:<16}{:<16}".format("!", "on-off", "target keff"))
        slist.append("{:<16}{:<16}{:<16.5f}".format("rod_search", bool2tf(self.rodSearch), self.targetKeff))
        slist.append("{:<16}{:<16}".format("!", "on-off"))
        slist.append("{:<16}{:<16}".format("worth", bool2tf(self.worth)))
        slist.append("{:<16}{:<16}{:<16}".format("!", "on-off", "neutron balance"))
        slist.append("{:<16}{:<16}{:<16}".format("reactivity", bool2tf(self.reactivity), bool2tf(self.neutronBalance)))
        slist.append("{:<16}{:<16}{:<16}{:<16}".format("!", "power", "VTK", "restart"))
        slist.append("{:<16}{:<16}{:<16}{:<16}".format("output", bool2tf(self.outputPower), bool2tf(self.outputVTK), bool2tf(self.restart)))
        slist.append("{:<16}{:<16}".format("!", "on-off"))
        slist.append("{:<16}{:<16}".format("th", bool2tf(self.thermal)))
        slist.append("{:<16}{:<16}".format("!", "on-off"))
        slist.append("{:<16}{:<16}".format("reconstruct", bool2tf(self.reconstruct)))
        slist.append("\n")

        # METHOD
        slist.append("! " + 36*"=" + " METHOD " + 36*"=")
        slist.append("METHOD:")
        slist.append("{:<16}{:<16}".format("!", "even integer"))
        slist.append("{:<16}{:<16d}".format("sn_order", self.SNOrder))
        slist.append("{:<16}{:<16}{:<16}{:<16}{:<16}{:<16}".format("!", "max_inner", "max_outer", "rms_inner", "rms_outer", "rms_eigen"))
        slist.append("{:<16}{:<16d}{:<16d}{:<16.1E}{:<16.1E}{:<16.1E}".format("error_eigen", self.maxInnerIter, self.maxOuterIter, self.RMSInner, self.RMSOuter, self.RMSEigen))
        slist.append("{:<16}{:<16}".format("!", "nThread"))
        slist.append("{:<16}{:<16}".format("openmp", self.openMPThread))
        slist.append("{:<16}{:<16}".format("!", "on-off"))
        slist.append("{:<16}{:<16}".format("cmacc", bool2tf(self.cmacc)))
        slist.append("{:<16}{:<16}".format("!", "spcae expansion order"))
        slist.append("{:<16}{:<16d}".format("space_order", self.spaceOrder))
        slist.append("\n")

        # MATERIAL (Actually SECTION)
        slist.append("! " + 36*"=" + " MATERIAL " + 36*"=")
        slist.append("MATERIAL:")
        slist.append("{:<16}{:<16}".format("!", "on-off"))
        slist.append("{:<16}{:<16}".format("low_scat_order", bool2tf(self.lowScatter)))
        slist.append("{:<16}{:<16}{:<16}{:<16}{:<16}".format("!", "mat id", "xs file", "temp id", "mat type"))
        for mat in sorted(self.sections, key=lambda x: x.id):
            slist.append("{:<16}{:<16d}{:<16}{:<16d}".format("mat_file", mat.id, "MAT{:d}".format(mat.id), 1))
        slist.append("\n")

        # GEOMETRY
        slist.append("! " + 36*"=" + " GEOMETRY " + 36*"=")
        slist.append("GEOMETRY:")

        # GEOMETRY: LAYER
        sLayer = []
        for grid in np.diff(self.meshgrid):
            sLayer.append("{:.4f}".format(grid))
        slist.append("{:<16}{:<16}{:<16}".format("!", "num_layer", "axial height"))
        slist.append("{:<16}{:<16d}{:<16}".format("layer", len(sLayer), " ".join(sLayer)))

        # GEOMETRY: BC_AXIAL
        slist.append("{:<16}{:<16}{:<16}".format("!", "bc bottom", "bc top"))
        slist.append("{:<16}{:<16d}{:<16d}".format("bc_axial", *self.boundaryConditions))

        # GEOMETRY: FA_TYPE
        slist.append("\n")
        slist.append("{:<16}{:<16}{:<32}{:<32}".format("!", "FA id", "assembly type", "assembly location"))
        for assembly in sorted(self.assemblies, key=lambda x: x.id):
            slist.append("{:<16}{:<16d}{:<32}{:<32}".format("!", assembly.id, assembly.type, assembly.location))
        slist.append("!" + 100*".")
        slist.append("{:<16}{:<16}{:<16}".format("!", "FA id", "layer mat id"))
        for assembly in sorted(self.assemblies, key=lambda x: x.id):
            slist.append(assembly.toLAVENDER(self.meshgrid, self.coolant))
        slist.append("\n")
        
        # GEOMETRY: HEX_DIM
        slist.append("{:<16}{:<16}{:<16}{:<16}".format("!", "degree", "ring", "pitch [cm]"))
        slist.append("{:<16}{:<16d}{:<16d}{:<16.4f}".format("hex_dim", 360, self.ring, self.pitch))

        # GEOMETRY: HEX_CONF
        slist.append("{:<16}{:<16}".format("!", "assembly lattice"))
        slist.append("hex_conf")

        # Traverse the core row-by-row
        #     l: row    r: ring    k: clockwise order
        for l in range(2*self.ring - 1):
            dis2centerLine = abs(self.ring - 1 - l)
            rowlist = [_INDENT, "{:>2d}".format(l+1), _INDENT, (dis2centerLine)*' ']

            # Go from outer ring to inner ring (120 ~ 240 degree)
            for j in range(self.ring - 1 - dis2centerLine):
                r = (self.ring - 1) - j
                k = 5 * r + j - l
                rowlist.append("{:>4}".format(self.lattice[r][k].id))
            
            # Go through the the inneset ring in current row (60 ~ 120 & 240 ~ 300 degree)
            r = dis2centerLine
            kCenterLine = 4 * r if r > 0 else 1
            for j in range(dis2centerLine):
                k = kCenterLine + (r + j) * int(np.sign(self.ring - 1 - l))
                rowlist.append("{:>4}".format(self.lattice[r][k].id))
            
            # The assembly in line of 60 & 300 degree
            k = 2 * dis2centerLine if self.ring - 1 - l < 0 else 0
            rowlist.append("{:>4}".format(self.lattice[r][k].id))

            # Go from the inner ring to outer ring (300 ~ 60 degree)
            for j in range(self.ring - 1 - dis2centerLine):
                r = 1 + j + dis2centerLine
                k = l + r + 1 - self.ring
                rowlist.append("{:>4}".format(self.lattice[r][k].id))
            
            slist.append(''.join(rowlist))
        slist.append("\n")

        # END
        slist.append("! " + 36*"=" + " END " + 36*"=")
        slist.append("END:")

        return '\n'.join(slist)

    def plotRaial(self, pitch=1.0, savePath=None):
        """
        Plot the radial structure of Core

        Input
        -----
        pitch: float, the pitch of core lattice
        savePath: pathLike, the path to save the image, ending with ".png", ".jpg", ".svg" or other supported format
        """
        # Check the completeness of Core
        if not self.completed:
            raise RuntimeError("Core has not completed yet. Please call Core.complete() first.")
        
        # Import matplotlib
        try:
            import matplotlib.pyplot as plt
            from matplotlib import patches
        except ImportError:
            # warnings.warn("Module matplotlib.pyplot could not be imported.")
            print("Warning: Module matplotlib.pyplot could not be imported.")
            return

        # Prepare data for plot
        hBound = pitch * (self.ring+1)
        vBound = pitch * (self.ring+1) * np.cos(np.pi/6)

        # Traverse every assembly and give color by their types
        xcoordinates = []
        ycoordinates = []
        ccoordinates = []
        assemblyTypes = set()
        for r in range(self.ring):
            numInRing = 6 * r if r > 0 else 1
            for k in range(numInRing):
                assembly = self.lattice[r][k]
                assemblyTypes.add(assembly.type)
                x, y = self.rk2xy(r, k, pitch=pitch)
                xcoordinates.append(x)
                ycoordinates.append(y)
                ccoordinates.append(assembly.type)
        
        # Convert type name to integer number
        assemblyTypes = list(assemblyTypes)
        for i, typeName in enumerate(assemblyTypes):
            for j in range(len(ccoordinates)):
                if ccoordinates[j] == typeName:
                    ccoordinates[j] = i + 1 # Color is white if C==0

        # The coordinates of the coolant outside of assemblies lattice (not exact)
        radius = pitch * self.ring
        coolantCirc = patches.Circle(xy=(0., 0.), radius=radius, fill=False)

        # Plot
        fig, axes = plt.subplots()
        axes.add_artist(coolantCirc)
        plt.hexbin(xcoordinates, ycoordinates, ccoordinates, gridsize=(2*self.ring-1-self.ring%2, self.ring-1))
        # plt.scatter(xcoordinates, ycoordinates, alpha=0.3)
        plt.xlim((-hBound, hBound))
        plt.ylim((-vBound, vBound))

        # Save
        if savePath:
            diretory, file = os.path.split(savePath)
            if not os.path.exists(diretory):
                # warnings.warn("The directory [{}] does not exist.".format(diretory))
                print("Warning: The directory [{}] does not exist.".format(diretory))
            else:
                plt.savefig(savePath)
        else:
            plt.show()

    def plotAxial(self, savePath=None):
        """
        Plot the axial structure of all types of Assembly (NOT Core)

        Input
        -----
        savePath: pathLike, the path to save the image, ending with ".png", ".jpg", ".svg" or other supported format
        """
        # Check the completeness of Core
        if not self.completed:
            raise RuntimeError("Core has not completed yet. Please call Core.complete() first.")
        
        # Import Matplotlib
        try:
            import matplotlib.pyplot as plt
            import matplotlib.colors as mcolors
        except ImportError:
            # warnings.warn("Module matplotlib.pyplot could not be imported.")
            print("Warning: Module matplotlib.pyplot could not be imported.")
            return
        
        # Create a new canvas, to prevent paint in the radial one
        plt.figure()
        plt.xticks(rotation=90)
        
        # Prepare data: one assembly represents one type
        assemblies = {}
        for assembly in self.assemblies:
            if assembly.type not in assemblies:
                assemblies[assembly.type] = assembly
        
        # Prepare data: count the total number of sections in representative assemblies
        sections = set()
        colors = list(mcolors.CSS4_COLORS.keys()) # 148 colors
        cmap = {}
        for assembly in assemblies.values():
            for sec in assembly.sections:
                sections.add(sec)
        for idx, sec in enumerate(sections):
            idx = idx % 148 # Prevent the idx >= 148, although it has a low probabliity
            cmap[sec] = colors[idx]

        # Plot: x-axis is assembly type, y-axis is the height of axial structure
        for typeName, assembly in assemblies.items():
            for sec in assembly.sections:
                lower, higher = sec.bounds
                if lower * higher >= 0:
                    if lower >= 0 and higher >= 0:
                        bottom, top = lower, higher
                    elif lower < 0 and higher <= 0:
                        bottom, top = higher, lower
                    plt.bar(x=[typeName], height=[top - bottom], bottom=[bottom], color=[cmap[sec]])
                else:
                    # The signs of two bounds are different, split this section into two
                    bottom, top = 0., higher
                    plt.bar(x=[typeName], height=[top], bottom=[bottom], color=[cmap[sec]])
                    bottom, top = lower, 0.
                    plt.bar(x=[typeName], height=[bottom], bottom=[top], color=[cmap[sec]])
        
        # Plot the reference plain
        plt.axhline(y=0.)
        # Plot the mesh grid
        for grid in self.meshgrid:
            plt.axhline(y=grid, alpha=0.3)

        # Save
        if savePath:
            diretory, file = os.path.split(savePath)
            if not os.path.exists(diretory):
                # warnings.warn("The directory [{}] does not exist.".format(diretory))
                print("Warning: The directory [{}] does not exist.".format(diretory))
            else:
                plt.savefig(savePath)
        else:
            plt.show()

    def rk2xy(self, r, k, pitch=1.0) -> tuple:
        """
        Convert the (ring,clock) coordinate to (x,y) coordinate

        Input
        -----
        r: int, the ring coordinate
        k: int, the clock coordinate
        pitch: float, the pitch of core lattice
        """
        # Check input
        if type(r) is not int or type(k) is not int:
            raise TypeError("Input coordinate is not type int.")
        
        # Handle the innest ring (single assembly)
        if r == 0:
            assert k == 0
            return (0., 0.)

        # Determine which sector is (r,k) in. 0: A, 1: B, ...
        sector = k // r
        # Determine which seat is (r,k) in this sector.
        seat = k % r

        # This first seat in sector (clockwise)
        degree = (1 - sector) * np.pi / 3
        radius = r * pitch
        x = radius * np.cos(degree)
        y = radius * np.sin(degree)

        # Move to the target seat
        degree -= 2 * np.pi / 3
        distance = seat * pitch
        x += distance * np.cos(degree)
        y += distance * np.sin(degree)

        return (x, y)

    def copy(self, name, deepcopy=False):
        """
        Create a copy of this Core

        Input
        -----
        deepcopy: bool, whether replace copy.copy() with copy.deepcopy()
        """
        coreCopy = Core(name=name, ring=self.ring)
        if deepcopy:
            coreCopy.lattice = copy.deepcopy(self.lattice)
        else:
            coreCopy.lattice = copy.copy(self.lattice)
        coreCopy.complete()
        return coreCopy


if __name__ == '__main__':
    csvpath = "C:\\SJTUGraduate\\Research\\Projects\\LoongSARAXVerif\\benchmark\\EBR2-LMFR-RESR-001\\Benchmark CSV Material Data Files\\Blankets\\11A01.csv"
    # driver = Assembly(typeName="driver", location="02C08")
    tulipPath = "C:\\SJTUGraduate\\Research\\Projects\\LoongSARAXVerif\\code\\pySARAX\\cases\\case0\\TPmate.inp"
    lavenderPath = "C:\\SJTUGraduate\\Research\\Projects\\LoongSARAXVerif\\code\\pySARAX\\cases\\case0\\lavender.inp"

    # Pre-read Benchmark Materials CSV Files
    df = pd.read_csv(csvpath)

    # ===================== Material =====================
    # Define Material - form 1: add nuclide one-by-one
    coolant = Material(name="water")
    coolant.addNuclide(nuclide="H1", density=0.5, temperature=_BULK_TEMP)
    coolant.addNuclide(nuclide="O16", density=0.25, temperature=_BULK_TEMP)
    print(coolant, '\n')

    # Define Material - form 2: from pandas.DataFrame
    fuel = Material(name="fuel")
    fuel.fromDataFrame(df=df[["ZAIDS", "S1"]])
    print(fuel, '\n')

    clad = Material(name="clad")
    clad.fromDataFrame(df=df[["ZAIDS", "S2"]])

    ss304 = Material(name="SS304")
    ss304.fromDataFrame(df=df[["ZAIDS", "S3"]])

    # Define Material - form 3: from CSV


    # ===================== Section =====================
    # Define Section
    mat1 = Section(name="fuel slug", ring=6, pitch=0.5665)
    mat1.append(shape="rod", size=0.3302, material=fuel)
    mat1.appendRod(size=0.3810, material=clad)
    mat1.appendRod(size=0.4591, material=coolant)
    mat1.append(shape="region", size=5.8166, material=ss304)
    mat1.appendRegion(size=5.8929, material=coolant)

    mat2 = Section(name="sodium", ring=0, pitch=0.5665)
    mat2.append(shape="region", size=5.8166, material=ss304)
    mat2.appendRegion(size=5.8929, material=coolant)

    
    # ===================== Assembly =====================
    # Define Assembly
    driver = Assembly(typeName="Driver", location="02C08")

    sodiumBelow = mat2.copy(name="sodium below fuel", deepcopy=True)
    sodiumBelow.bounds = (-2., -1.)
    driver.addSection(sodiumBelow)

    fuel = mat1.copy(name="fuel slug 1", deepcopy=True)
    fuel.bounds = (-1., 1.)
    driver.addSection(fuel)

    sodiumAbove = mat2.copy(name="@ORIGIN above fuel", deepcopy=True)
    sodiumAbove.bounds = (1., 2.)
    driver.addSection(sodiumAbove)

    print(driver, '\n')
    for sec in driver.sections:
        print(sec, '\n')
    
    
    # ===================== Assemblies =====================
    # Define Assemblies
    # ring 1
    ring1 = Assemblies(name="ring1")
    assembly = driver.copy(deepcopy=True)
    assembly.location = "01A01"
    ring1.addAssembly(assembly)

    # ring 2
    ring2 = Assemblies(name="ring2")
    for i in range(6):
        assembly = driver.copy(deepcopy=True)
        assembly.location = "02A{:0>2d}".format(i+1)
        assembly.type = "driver-{}".format(i+1)
        delta = 0.1 * i + 0.05 * (i % 2)
        assembly.sections[0].bounds = (1.0+delta, 2.0+delta)
        assembly.sections[1].bounds = (-1.0-delta, 1.0+delta)
        assembly.sections[2].bounds = (-2.0-delta, -1.0-delta)
        ring2.addAssembly(assembly)
    # Replace the last assembly in ring 2
    control = driver.copy(deepcopy=True)
    control.type = "control"
    ring2.assemblies[-1] = control

    # ring 3
    ring3 = Assemblies(name="ring3")
    for i in range(12):
        assembly = driver.copy(deepcopy=True)
        assembly.location = "03A{:0>2d}".format(i+1)
        ring3.addAssembly(assembly)
    
    rings = [ring1, ring2, ring3]

    
    # ===================== Core =====================
    # Define Core - Form 1
    core1 = Core(name="core1", ring=3, pitch=5.8929, coolant=mat2)
    core1.addRing(ring1)
    core1.addRing(ring2)
    core1.addRing(ring3)
    for r in core1.lattice:
        print(r, '\n')

    # Define Core - Form 2
    core2 = Core(name="core2", ring=3, pitch=5.8929, coolant=mat2)
    core2.lattice = rings
    
    
    # ===================== Output =====================
    # Complete the Core
    core1.complete()
    # for m in core1.materials:
    #     print(m)
    # for mat in core1.sections:
    #     print(mat)
    # for assembly in core1.assemblies:
    #     print(assembly)

    # CAUTION: The template materials will NOT have ID, since they are NOT included in the Core
    # # Export material to TULIP
    # print(coolant.toTULIP(), '\n')

    # # Export geometry to TULIP
    # print(fuel.toTULIP(), '\n')
    # print(sodiumAbove.toTULIP(), '\n')

    # Create a copy of Core
    # core3 = core1.copy(name="core3", deepcopy=True)
    # core3.ring = 2
    # core3.lattice = core3.lattice[:2]
    # core3.plotRaial()
    # core3.meshing()

    # Create a copy and add extra ring 4, to demonstrate the plotRadial()
    # ring4 = Assemblies(name="ring4")
    # for _ in range(18):
    #     ring4.addAssembly(assembly=control)
    # core4 = core1.copy(name="core4", deepcopy=True)
    # core4.ring = 4
    # core4.lattice.append(ring4)
    # core4.complete()
    # core4.plotRaial()

    # Meshing
    core1.meshing()

    # Output the Core info to LAVENDER
    with open(tulipPath, 'w', encoding='utf-8') as tulip:
        tulip.write(core1.toTULIP())
    
    with open(lavenderPath, 'w', encoding='utf-8') as lavender:
        lavender.write(core1.toLAVENDER())

    # Plot radial structure of core
    core1.plotRaial(savePath="C:\\SJTUGraduate\\Research\\Projects\\LoongSARAXVerif\\code\\pySARAX\\cases\\case0\\radial.png")

    # Plot the axial structure of assembly
    core1.plotAxial(savePath="C:\\SJTUGraduate\\Research\\Projects\\LoongSARAXVerif\\code\\pySARAX\\cases\\case0\\axial.png")

